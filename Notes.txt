-Terraform destroy command destroys everything in the infrastructure. This command is not recommended in prod environment.
-VPC - Virtual Private Cloud  
-Amazon Virtual Private Cloud (VPC) gives you complete control over your virtual networking environment, 
    including resource placement, connectivity, and security. The first step is to create your VPC. 
    Then you can add resources to it, such as Amazon Elastic Compute Cloud (EC2) and 
    Amazon Relational Database Service (RDS) instances. Finally, you can define how your VPCs communicate with each other 
    across accounts, Availability Zones (AZs), or Regions.
-Terraform.tfstate file is absolutely crucial to the functioning of Terraform. Don't mess around with this file.

-Advanced project plan 
    1.Create VPC
    2.Create Internet Gateway
    3.Create Custom Route Table (optional but cool to look at)
    4.Create a Subnet where our webserver is going to reside on
    5.Associate subnet with Route Table
    6.Create security group to allow port 22(SSH), 80(http), 443 (https)
    7.Create a network interface with an ip in the subnet that was created in step 4
    8.Assign an elastic IP to the network interface created in step 7 (Elastic IP is a public IP that's routable on the internet)
    9.Create ubuntu server and install/enable apache2

- When you make a key pair, use pem if you're a linux or mac user, use ppk if you're windows putty user.    

- In a home or small office environment, the default gateway is a device, such as a DSL router or cable router, 
  that connects the local network to the Internet. ... A device wishing to communicate with a host on the public Internet, 
  for example, forwards the packet to the default gateway for its network segment.

- In routing tables, 0.0.0.0 can appear in the gateway column. This indicates that the gateway to reach the corresponding 
  destination subnet is unspecified. This generally means that no intermediate routing hops are necessary because the system is 
  directly connected to the destination.  

- Egress in the world of networking implies traffic that exits an entity or a network boundary, while Ingress is traffic that 
  enters the boundary of a network.  

- Classless Inter-Domain Routing (CIDR) block basically is a method for allocating IP addresses and IP routing. 
  When you create a network or route table, you need to specify what range you are working in. 
  "0.0.0.0" means that it will match to any IP address. Some IP addresses are specific, like 10.0.0.0  
  which will match to any IP address beginning with 10.

- NOTE: Some of the IP address in a range are reserved for various purposes. According to AWS VPC documentation, 
 following are the reserved IP addresses.
    10.0.0.0: Network address.
    10.0.0.1: Reserved by AWS for the VPC router.
    10.0.0.2: Reserved by AWS. The IP address of the DNS server is always the base of the VPC network range plus two; however, we also reserve the base of each subnet range plus two. For VPCs with multiple CIDR blocks, the IP address of the DNS server is located in the primary CIDR. For more information, see Amazon DNS Server.
    10.0.0.3: Reserved by AWS for future use.
    10.0.0.255: Network broadcast address. We do not support broadcast in a VPC, therefore we reserve this address.  


-To destroy terrafrom so that you won't be billed:    terraform destroy --auto-approve

-The command "terraform state list" lists all of the resources that we have created a state for.

-And to see more about the items listed do this command: "terraform state show aws_eip.one"

-terraform refresh would show ouput blocks without applying or potentially modifying anything.

-"terraform destroy -target aws_instance.web-server-instance"  //destroys only the webserver

-"terraform apply -target aws_instance.web-server-instance"  //applys only the webserver

- a variable can be passed after "terraform apply" or

- a variable can also be passed from the command line like: "terraform apply -var "subnet_prefix=10.0.100.0/24"

- best way to use is to use a separate file for variable assignment

- If nothing is provided provided, terraform can use a default, which is specified under the variable declaration block

- It is also possible to use objects in terraform.tfvars file:
    subnet_prefix = [{ cidr_block = "10.0.1.0/24", name = "prod_subnet" }, { cidr_block = "10.0.2.0/24", name = "dev_subnet" }]


Terraform with Azure:

Imperative vs Declartive
- Imperative is when the system is told how to do something which means I'm responsible for checking current state, handling errors.
- With Declarative you state the desired state, you don't have to check. It's the job of that tech to make it so. e.g Terraform.
  -Terraform is a declarative technology.

- Terraform is written in Go (as our plugins)  

- Plugins provide service specific integration including an Azure provider

Azure loves declarative

Azure's state is stored as JSON.

- Terraform is natively available in the Azure cloud shell

- Pessimistic constrainit operator (~) tilde: it says that we are using version 2 or above but not a major version change (not version 3)

terraform {
    required_providers {
      azurerm = {
        source  = "hashicorp/azurerm"
        version = "~>2.31.1"
      }
    }
}

- terraform init is the first command we run after creating our main.tf file
  terraform plan
  terraform apply
  terraform destroy

- The command "terraform fmt" formats main.tf file for spacing and good redability and saves it automatically.

- The command "terraform validate" checks for syntax error

- What happens when someone changes a resource setting in the cloud manually after the resource is created by terraform. When that happens, we can
  run the command "terraform refresh" and what that does is changes/updates the terraform.tfstate file to match the cloud changed state in the local state file.

- But this is not ideal, when collaborating with other developers, it's not ideal to store state files in your local. You can use terraform cloud or 
  Amazon s3 to store this state file remotely

- After signing up to terraform module to store state file remotely and setting up organization and workspace and updating your local main.tf with the remote
information, run "terraform init". You will see the following:

Pre-existing state was found while migrating the previous "local" backend to the
  newly configured "remote" backend. No existing state was found in the newly
  configured "remote" backend. Do you want to copy this state to the new "remote"
  backend? Enter "yes" to copy and "no" to start with an empty state.

- You can also provide a partial configuration in main.tf and provide the missing info from an environment variable or from a command line.
  For example if you remove the line organization = "blitzNetwork"  from main.tf file you can run the init command like this:

    terraform init -backend-config="organization=blitzNetwork" 


Terraform with multiple state files?

VNets or Virtual Networks:
- When you create a virtual machine (VM), you create a virtual network or use an existing one.
- You can create a virtual network before you create a virtual machine or you can create the virtual network as you create a virtual machine.
- You create these resources to support communication with a virtual machine:
    -Network interfaces
    -IP addresses
    -Virtual network and subnets
- Additionally, consider these optional resources:
    -Network security groups
    -Load balancers

- Azure CLI
  - az login
  - az account list

    
      
Terraform Variables:
 - Variable Types
   variable "server_name" {
     type = string
     default = "web-server"
   }

   variable "server_number" {
     type = number
     default = 1
   }

   variable "provision_vm_agent" {
     type = bool
     default = true
   }


- Complex Variables

  variable "servers" {
    type    = list(string)
    default = ["webserver01", "webserver02"]
  }

  variable "subnets" {
    type    = map
    default = {
      web-server          = "1.0.1.0/24"
      AzureBastionSubnet  = "1.0.2.0/24"
    }
  }
 
 In terrafrm when a variable is set to null, it is as if it's never created.

Input variables are like function arguments.
Output values are like function return values.
Local values are like a function's temporary local variables.

input variables are often referred to as just "variables" or "Terraform variables" 
when it is clear from context what sort of variable is being discussed. Other kinds of variables in 
Terraform include environment variables (set by the shell where Terraform runs) and 
expression variables (used to indirectly represent a value in an expression).

Environment variables can be used to set variables. The environment variables must be in the 
format TF_VAR_name and this will be checked last for a value. 

vaiables can be defined using variable files and individual variables from the command line, like so:

  terraform apply -var-file "vars.tfvars" -var "server=web"

In terraform you can inspect variables from "terraform console" from the command line:
= terraform console
- var.server_name
- length(var.servers)   // if the variable servers is a list
- var.subnets["web-server"]    //to see a specific value in a list

- Embedded within strings in Terraform, whether you're using the Terraform syntax or JSON syntax, 
  you can interpolate other values. These interpolations are wrapped in ${} , such as ${var. foo}.

  - count_string = format("%02d", count.index)

- What is carbon black? Carbon Black is a premier endpoint security tool that provides ransomware and malware protection while 
  facilitating threat hunting and incident response.
- What are gold images? (latest and greatest version of a server build)
- What is a tripwire: Open Source Tripwire is a free software security and data integrity tool for monitoring and alerting on 
  specific file change(s) on a range of systems.

az account list-locations -o table

//YOu can also use other output methods to list locations like JSON

A network security group (NSG) contains a list of Access Control List (ACL) rules that allow or deny network traffic to subnets, 
NICs, or both. NSGs can be associated with either subnets or individual NICs connected to a subnet. When an NSG is associated with a 
subnet, the ACL rules apply to all the VMs in that subnet. 
Traffic to an individual NIC can be restricted by associating an NSG directly to a NIC.

NSGs contain two sets of rules, inbound and outbound. The priority for a rule must be unique within each set.

If you run "terraform graph", it will show you the current representation of your resources in a graph.

you can go to this site:  https://dreampuf.github.io/GraphvizOnline/ and actually visualize the graph text output visually


